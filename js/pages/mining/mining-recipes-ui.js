/**
 * Mining recipes UI – list recipes, add/edit/remove (inputs/outputs with ratios)
 */
(function () {
    function getMaterials() {
        return window.getMaterials ? window.getMaterials() : [];
    }

    function materialOptions() {
        var materials = getMaterials();
        if (materials.length === 0) return '<option value="">— No materials —</option>';
        return materials.map(function (m) {
            return '<option value="' + m.id + '">' + (m.type || '') + ' ' + (m.name || '') + ' (TIER ' + m.tier + ')</option>';
        }).join('');
    }

    function generateRecipeName() {
        var materials = getMaterials();
        var inputs = [];
        var outputs = [];
        var tier = null;

        document.querySelectorAll('.recipe-input-row').forEach(function (row) {
            var sel = row.querySelector('.recipe-input-material');
            var qty = row.querySelector('.recipe-input-qty');
            var materialId = 0;
            if (sel) materialId = sel.value;
            var q = 0;
            if (qty && qty.value !== '') q = parseFloat(qty.value) || 0;
            if (materialId && q > 0) {
                var mat = materials.find(function (m) { return m.id == materialId; });
                if (mat) {
                    if (tier === null) tier = mat.tier || 1;
                    var label = (q !== 1 ? q + '× ' : '') + (mat.type || '') + ' ' + (mat.name || '');
                    inputs.push(label);
                }
            }
        });

        document.querySelectorAll('.recipe-output-row').forEach(function (row) {
            var sel = row.querySelector('.recipe-output-material');
            var qty = row.querySelector('.recipe-output-qty');
            var materialId = 0;
            if (sel) materialId = sel.value;
            var q = 0;
            if (qty && qty.value !== '') q = parseFloat(qty.value) || 0;
            if (materialId && q > 0) {
                var mat = materials.find(function (m) { return m.id == materialId; });
                if (mat) {
                    if (tier === null) tier = mat.tier || 1;
                    var label = (q !== 1 ? q + '× ' : '') + (mat.type || '') + ' ' + (mat.name || '');
                    outputs.push(label);
                }
            }
        });

        if (inputs.length === 0 && outputs.length === 0) return '';

        var namePart = '';
        if (inputs.length === 0) {
            namePart = outputs.join(' + ');
        } else if (outputs.length === 0) {
            namePart = inputs.join(' + ');
        } else {
            namePart = inputs.join(' + ') + ' → ' + outputs.join(' + ');
        }

        // Add tier prefix if available
        if (tier !== null) {
            return 'TIER ' + tier + ': ' + namePart;
        }

        return namePart;
    }

    function updateRecipeName() {
        var nameEl = document.getElementById('recipeNameInput');
        if (!nameEl) return;

        // Only auto-update if name field is empty or was auto-generated (check if it matches current auto-name)
        var currentName = nameEl.value.trim();
        var autoName = generateRecipeName();

        // If name is empty or matches previous auto-name, update it
        if (!currentName || nameEl.dataset.autoGenerated === 'true') {
            nameEl.value = autoName;
            nameEl.dataset.autoGenerated = 'true';
        }
    }

    function addInputRow() {
        var container = document.getElementById('recipeInputsContainer');
        if (!container) return;
        var row = document.createElement('div');
        row.className = 'row g-2 mb-2 recipe-input-row';
        row.innerHTML = '<div class="col-md-8"><select class="form-select form-select-sm recipe-input-material">' + materialOptions() + '</select></div>' +
            '<div class="col-md-3"><input type="number" class="form-control form-control-sm recipe-input-qty" min="0.001" step="any" value="1" placeholder="Qty"></div>' +
            '<div class="col-md-1"><button type="button" class="btn btn-sm btn-outline-danger recipe-remove-input" aria-label="Remove">×</button></div>';
        container.appendChild(row);

        // Add event listeners for auto-name generation
        var materialSel = row.querySelector('.recipe-input-material');
        var qtyInput = row.querySelector('.recipe-input-qty');
        if (materialSel) {
            materialSel.addEventListener('change', updateRecipeName);
        }
        if (qtyInput) {
            qtyInput.addEventListener('input', updateRecipeName);
            qtyInput.addEventListener('change', updateRecipeName);
        }

        row.querySelector('.recipe-remove-input').addEventListener('click', function () {
            row.remove();
            updateRecipeName();
        });
    }

    function addOutputRow() {
        var container = document.getElementById('recipeOutputsContainer');
        if (!container) return;
        var row = document.createElement('div');
        row.className = 'row g-2 mb-2 recipe-output-row';
        row.innerHTML = '<div class="col-md-8"><select class="form-select form-select-sm recipe-output-material">' + materialOptions() + '</select></div>' +
            '<div class="col-md-3"><input type="number" class="form-control form-control-sm recipe-output-qty" min="0.001" step="any" value="1" placeholder="Qty"></div>' +
            '<div class="col-md-1"><button type="button" class="btn btn-sm btn-outline-danger recipe-remove-output" aria-label="Remove">×</button></div>';
        container.appendChild(row);

        // Add event listeners for auto-name generation
        var materialSel = row.querySelector('.recipe-output-material');
        var qtyInput = row.querySelector('.recipe-output-qty');
        if (materialSel) {
            materialSel.addEventListener('change', updateRecipeName);
        }
        if (qtyInput) {
            qtyInput.addEventListener('input', updateRecipeName);
            qtyInput.addEventListener('change', updateRecipeName);
        }

        row.querySelector('.recipe-remove-output').addEventListener('click', function () {
            row.remove();
            updateRecipeName();
        });
    }

    function collectRecipeFromModal() {
        var nameEl = document.getElementById('recipeNameInput');
        var name = nameEl ? nameEl.value.trim() : '';
        var inputs = [];
        document.querySelectorAll('.recipe-input-row').forEach(function (row) {
            var sel = row.querySelector('.recipe-input-material');
            var qty = row.querySelector('.recipe-input-qty');
            var materialId = 0;
            if (sel) materialId = sel.value;
            var q = 0;
            if (qty && qty.value !== '') q = parseFloat(qty.value) || 0;
            if (materialId && q > 0) {
                inputs.push({ materialId: materialId, quantity: q });
            }
        });
        var outputs = [];
        document.querySelectorAll('.recipe-output-row').forEach(function (row) {
            var sel = row.querySelector('.recipe-output-material');
            var qty = row.querySelector('.recipe-output-qty');
            var materialId = 0;
            if (sel) materialId = sel.value;
            var q = 0;
            if (qty && qty.value !== '') q = parseFloat(qty.value) || 0;
            if (materialId && q > 0) {
                outputs.push({ materialId: materialId, quantity: q });
            }
        });
        return { name: name || null, inputs: inputs, outputs: outputs };
    }

    function showRecipeError(msg) {
        var el = document.getElementById('addRecipeError');
        if (el) {
            el.textContent = msg || '';
            el.style.display = msg ? 'block' : 'none';
        }
    }

    window.renderRecipes = function () {
        var container = document.getElementById('recipesContainer');
        var emptyEl = document.getElementById('recipesEmptyState');
        var filterEmptyEl = document.getElementById('recipesFilterEmptyState');
        var filterInput = document.getElementById('recipeFilterInput');
        if (!container) return;
        var recipes = window.getRecipes ? window.getRecipes() : [];
        var materials = getMaterials();

        if (recipes.length === 0) {
            container.innerHTML = '';
            if (emptyEl) emptyEl.style.display = 'block';
            if (filterEmptyEl) filterEmptyEl.style.display = 'none';
            return;
        }
        if (emptyEl) emptyEl.style.display = 'none';

        // Get filter text
        var filterText = filterInput ? filterInput.value.trim().toLowerCase() : '';

        function materialLabel(id) {
            var m = materials.find(function (mat) { return mat.id == id; });
            return m ? m.type + ' ' + m.name : 'id=' + id;
        }

        function getMaterialType(id) {
            var m = materials.find(function (mat) { return mat.id == id; });
            return m ? (m.type || 'ore').toLowerCase() : 'ore';
        }

        function getRecipeTier(recipe) {
            // Get tier from inputs first, then outputs
            var tier = null;
            if (recipe.inputs && recipe.inputs.length > 0) {
                var inputMat = materials.find(function (m) { return m.id == recipe.inputs[0].materialId; });
                if (inputMat) tier = inputMat.tier || 1;
            }
            if (tier === null && recipe.outputs && recipe.outputs.length > 0) {
                var outputMat = materials.find(function (m) { return m.id == recipe.outputs[0].materialId; });
                if (outputMat) tier = outputMat.tier || 1;
            }
            return tier || 1;
        }

        function getRecipeTypeProgression(recipe) {
            // Check if it's Ore->Ingot (priority 1) or Ingot->Sheet (priority 2)
            var hasOreInput = false;
            var hasIngotInput = false;
            var hasIngotOutput = false;
            var hasSheetOutput = false;

            if (recipe.inputs && recipe.inputs.length > 0) {
                recipe.inputs.forEach(function (input) {
                    var type = getMaterialType(input.materialId);
                    if (type === 'ore') hasOreInput = true;
                    if (type === 'ingot') hasIngotInput = true;
                });
            }

            if (recipe.outputs && recipe.outputs.length > 0) {
                recipe.outputs.forEach(function (output) {
                    var type = getMaterialType(output.materialId);
                    if (type === 'ingot') hasIngotOutput = true;
                    if (type === 'sheet') hasSheetOutput = true;
                });
            }

            if (hasOreInput && hasIngotOutput) return 1; // Ore->Ingot
            if (hasIngotInput && hasSheetOutput) return 2; // Ingot->Sheet
            return 3; // Other
        }

        // Filter recipes if filter text is provided
        var filteredRecipes = recipes;
        if (filterText) {
            filteredRecipes = recipes.filter(function (r) {
                // Check recipe name
                var nameMatch = (r.name || '').toLowerCase().includes(filterText);
                if (nameMatch) return true;

                // Check tier
                var tier = getRecipeTier(r);
                if (('tier ' + tier).includes(filterText) || ('t' + tier).includes(filterText)) return true;

                // Check inputs
                var inputMatch = false;
                if (r.inputs && r.inputs.length > 0) {
                    r.inputs.forEach(function (input) {
                        var mat = materials.find(function (m) { return m.id == input.materialId; });
                        if (mat) {
                            var label = (mat.type || '') + ' ' + (mat.name || '');
                            if (label.toLowerCase().includes(filterText)) inputMatch = true;
                        }
                    });
                }
                if (inputMatch) return true;

                // Check outputs
                var outputMatch = false;
                if (r.outputs && r.outputs.length > 0) {
                    r.outputs.forEach(function (output) {
                        var mat = materials.find(function (m) { return m.id == output.materialId; });
                        if (mat) {
                            var label = (mat.type || '') + ' ' + (mat.name || '');
                            if (label.toLowerCase().includes(filterText)) outputMatch = true;
                        }
                    });
                }
                if (outputMatch) return true;

                // Check type progression
                var prog = getRecipeTypeProgression(r);
                if (filterText === 'ore' && prog === 1) return true;
                if (filterText === 'ingot' && (prog === 1 || prog === 2)) return true;
                if (filterText === 'sheet' && prog === 2) return true;

                return false;
            });
        }

        // Sort recipes: Tier first, then type progression (Ore->Ingot, then Ingot->Sheet)
        var sortedRecipes = filteredRecipes.slice().sort(function (a, b) {
            var tierA = getRecipeTier(a);
            var tierB = getRecipeTier(b);
            if (tierA !== tierB) return tierA - tierB;

            var progA = getRecipeTypeProgression(a);
            var progB = getRecipeTypeProgression(b);
            return progA - progB;
        });

        if (sortedRecipes.length === 0 && filterText) {
            container.innerHTML = '';
            if (filterEmptyEl) filterEmptyEl.style.display = 'block';
            return;
        }
        if (filterEmptyEl) filterEmptyEl.style.display = 'none';

        var html = '<div class="table-responsive"><table class="table table-striped table-hover mining-table"><thead><tr><th>Name</th><th>Inputs</th><th>Outputs</th><th>Actions</th></tr></thead><tbody>';
        sortedRecipes.forEach(function (r) {
            var inStr = (r.inputs || []).map(function (i) { return i.quantity + '× ' + materialLabel(i.materialId); }).join(', ') || '—';
            var outStr = (r.outputs || []).map(function (o) { return o.quantity + '× ' + materialLabel(o.materialId); }).join(', ') || '—';
            html += '<tr data-recipe-id="' + r.id + '"><td>' + (r.name || 'Recipe #' + r.id) + '</td><td>' + inStr + '</td><td>' + outStr + '</td>';
            html += '<td><button type="button" class="btn btn-sm btn-primary btn-edit-recipe me-1" data-id="' + r.id + '">Edit</button>';
            html += '<button type="button" class="btn btn-sm btn-danger btn-remove-recipe" data-id="' + r.id + '">Remove</button></td></tr>';
        });
        html += '</tbody></table></div>';
        container.innerHTML = html;

        container.querySelectorAll('.btn-edit-recipe').forEach(function (btn) {
            btn.addEventListener('click', function () {
                var id = this.dataset.id;
                if (window.openEditRecipeModal) window.openEditRecipeModal(id);
            });
        });

        container.querySelectorAll('.btn-remove-recipe').forEach(function (btn) {
            btn.addEventListener('click', function () {
                var id = this.dataset.id;
                if (!confirm('Remove this recipe?')) return;
                window.removeRecipe(id);
                if (window.MiningAPI && window.MiningAPI.deleteRecipe) {
                    window.MiningAPI.deleteRecipe(id).then(function (res) {
                        if (res.ok && window.loadMiningData) window.loadMiningData().then(function () { window.renderRecipes(); if (window.renderProfitAnalysis) window.renderProfitAnalysis(); });
                    });
                }
                window.renderRecipes();
                if (window.renderProfitAnalysis) window.renderProfitAnalysis();
            });
        });

        // Wire up filter input
        if (filterInput) {
            filterInput.addEventListener('input', function () {
                window.renderRecipes();
            });
            filterInput.addEventListener('keyup', function () {
                window.renderRecipes();
            });
        }
    };

    window.openAddRecipeModal = function () {
        var materials = getMaterials();
        if (materials.length === 0) {
            alert('Add at least one material first (Ore/Ingot/Sheet) before creating a recipe.');
            return;
        }
        // Reset modal for adding
        var modal = document.getElementById('addRecipeModal');
        var titleEl = document.getElementById('addRecipeModalLabel');
        var saveBtn = document.getElementById('saveRecipeBtn');
        if (titleEl) titleEl.textContent = 'Add Recipe';
        if (saveBtn) {
            saveBtn.textContent = 'Save Recipe';
            saveBtn.dataset.recipeId = '';
        }
        var nameEl = document.getElementById('recipeNameInput');
        if (nameEl) {
            nameEl.value = '';
            nameEl.dataset.autoGenerated = 'true';
            // Allow manual editing - if user types, mark as manual
            nameEl.addEventListener('input', function () {
                if (this.value.trim() !== generateRecipeName()) {
                    this.dataset.autoGenerated = 'false';
                }
            }, { once: false });
        }
        var inputsContainer = document.getElementById('recipeInputsContainer');
        var outputsContainer = document.getElementById('recipeOutputsContainer');
        if (inputsContainer) inputsContainer.innerHTML = '';
        if (outputsContainer) outputsContainer.innerHTML = '';
        showRecipeError('');
        addInputRow();
        addOutputRow();
        // Initial auto-name update
        setTimeout(updateRecipeName, 100);
        if (modal && window.bootstrap) {
            var bsModal = new bootstrap.Modal(modal);
            bsModal.show();
        }
    };

    window.openEditRecipeModal = function (recipeId) {
        var materials = getMaterials();
        if (materials.length === 0) {
            alert('Add at least one material first (Ore/Ingot/Sheet) before editing a recipe.');
            return;
        }
        var recipes = window.getRecipes ? window.getRecipes() : [];
        var recipe = recipes.find(function (r) { return r.id == recipeId; });
        if (!recipe) {
            alert('Recipe not found');
            return;
        }

        // Set modal for editing
        var modal = document.getElementById('addRecipeModal');
        var titleEl = document.getElementById('addRecipeModalLabel');
        var saveBtn = document.getElementById('saveRecipeBtn');
        if (titleEl) titleEl.textContent = 'Edit Recipe';
        if (saveBtn) {
            saveBtn.textContent = 'Update Recipe';
            saveBtn.dataset.recipeId = recipeId;
        }

        // Populate name
        var nameEl = document.getElementById('recipeNameInput');
        if (nameEl) {
            nameEl.value = recipe.name || '';
            nameEl.dataset.autoGenerated = 'false'; // Don't auto-update existing names
            // Allow manual editing - if user types, mark as manual
            nameEl.addEventListener('input', function () {
                if (this.value.trim() !== generateRecipeName()) {
                    this.dataset.autoGenerated = 'false';
                }
            }, { once: false });
        }

        // Clear and populate inputs
        var inputsContainer = document.getElementById('recipeInputsContainer');
        var outputsContainer = document.getElementById('recipeOutputsContainer');
        if (inputsContainer) inputsContainer.innerHTML = '';
        if (outputsContainer) outputsContainer.innerHTML = '';

        // Add input rows
        if (recipe.inputs && recipe.inputs.length > 0) {
            recipe.inputs.forEach(function (input) {
                addInputRow();
                var rows = inputsContainer.querySelectorAll('.recipe-input-row');
                var lastRow = rows[rows.length - 1];
                if (lastRow) {
                    var sel = lastRow.querySelector('.recipe-input-material');
                    var qty = lastRow.querySelector('.recipe-input-qty');
                    if (sel) sel.value = input.materialId || '';
                    if (qty) qty.value = input.quantity || 1;
                }
            });
        } else {
            addInputRow();
        }

        // Add output rows
        if (recipe.outputs && recipe.outputs.length > 0) {
            recipe.outputs.forEach(function (output) {
                addOutputRow();
                var rows = outputsContainer.querySelectorAll('.recipe-output-row');
                var lastRow = rows[rows.length - 1];
                if (lastRow) {
                    var sel = lastRow.querySelector('.recipe-output-material');
                    var qty = lastRow.querySelector('.recipe-output-qty');
                    if (sel) sel.value = output.materialId || '';
                    if (qty) qty.value = output.quantity || 1;
                }
            });
        } else {
            addOutputRow();
        }

        showRecipeError('');
        if (modal && window.bootstrap) {
            var bsModal = new bootstrap.Modal(modal);
            bsModal.show();
        }
    };

    function wireAddRecipeModal() {
        var addInputBtn = document.getElementById('addRecipeInputRow');
        var addOutputBtn = document.getElementById('addRecipeOutputRow');
        var saveBtn = document.getElementById('saveRecipeBtn');
        var nameEl = document.getElementById('recipeNameInput');
        var autoNameBtn = document.getElementById('autoGenerateRecipeNameBtn');

        if (addInputBtn) addInputBtn.addEventListener('click', addInputRow);
        if (addOutputBtn) addOutputBtn.addEventListener('click', addOutputRow);

        // Wire up auto-name button
        if (autoNameBtn) {
            autoNameBtn.addEventListener('click', function () {
                var autoName = generateRecipeName();
                if (nameEl && autoName) {
                    nameEl.value = autoName;
                    nameEl.dataset.autoGenerated = 'true';
                    // Trigger input event to ensure it's recognized
                    nameEl.dispatchEvent(new Event('input'));
                }
            });
        }

        // Wire up name field to detect manual edits
        if (nameEl) {
            nameEl.addEventListener('input', function () {
                var currentValue = this.value.trim();
                var autoValue = generateRecipeName();
                if (currentValue !== autoValue) {
                    this.dataset.autoGenerated = 'false';
                }
            });
        }
        if (saveBtn) {
            saveBtn.addEventListener('click', function () {
                var data = collectRecipeFromModal();
                if (data.inputs.length === 0) {
                    showRecipeError('Add at least one input (material + quantity).');
                    return;
                }
                if (data.outputs.length === 0) {
                    showRecipeError('Add at least one output (material + quantity).');
                    return;
                }
                showRecipeError('');

                var recipeId = this.dataset.recipeId;
                var isEdit = recipeId && recipeId !== '';

                function closeModalAndRefresh() {
                    var modal = document.getElementById('addRecipeModal');
                    if (modal && window.bootstrap) { var m = bootstrap.Modal.getInstance(modal); if (m) m.hide(); }
                    window.renderRecipes();
                    if (window.renderProfitAnalysis) window.renderProfitAnalysis();
                }

                if (isEdit) {
                    // Update existing recipe
                    if (window.MiningAPI && window.MiningAPI.updateRecipe) {
                        window.MiningAPI.updateRecipe(recipeId, data).then(function (res) {
                            if (res.ok && window.loadMiningData) {
                                window.loadMiningData().then(closeModalAndRefresh);
                            } else {
                                window.updateRecipe(recipeId, data);
                                closeModalAndRefresh();
                            }
                        });
                    } else {
                        window.updateRecipe(recipeId, data);
                        closeModalAndRefresh();
                    }
                } else {
                    // Create new recipe
                    if (window.MiningAPI && window.MiningAPI.createRecipe) {
                        window.MiningAPI.createRecipe(data).then(function (res) {
                            if (res.ok && window.loadMiningData) {
                                window.loadMiningData().then(closeModalAndRefresh);
                            } else {
                                window.addRecipe(data);
                                closeModalAndRefresh();
                            }
                        });
                    } else {
                        window.addRecipe(data);
                        closeModalAndRefresh();
                    }
                }
            });
        }
    }

    window.autoGenerateMissingRecipes = async function () {
        var materials = getMaterials();
        var recipes = window.getRecipes ? window.getRecipes() : [];

        if (materials.length === 0) {
            alert('Add at least one material first before generating recipes.');
            return;
        }

        // Group materials by name and tier
        var byNameAndTier = {};
        materials.forEach(function (m) {
            var key = (m.name || '').toLowerCase() + '_tier' + (m.tier || 1);
            if (!byNameAndTier[key]) {
                byNameAndTier[key] = {
                    name: m.name,
                    tier: m.tier || 1,
                    ore: null,
                    ingot: null,
                    sheet: null
                };
            }
            var type = (m.type || 'ore').toLowerCase();
            if (type === 'ore') byNameAndTier[key].ore = m;
            if (type === 'ingot') byNameAndTier[key].ingot = m;
            if (type === 'sheet') byNameAndTier[key].sheet = m;
        });

        // Check which recipes exist
        function recipeExists(inputMaterialId, outputMaterialId) {
            return recipes.some(function (r) {
                var hasInput = (r.inputs || []).some(function (i) { return i.materialId == inputMaterialId; });
                var hasOutput = (r.outputs || []).some(function (o) { return o.materialId == outputMaterialId; });
                return hasInput && hasOutput;
            });
        }

        var created = [];
        var skipped = [];

        // Generate Ore→Ingot recipes (5 Ore → 1 Ingot)
        for (var key in byNameAndTier) {
            var group = byNameAndTier[key];
            if (group.ore && group.ingot) {
                if (!recipeExists(group.ore.id, group.ingot.id)) {
                    var recipeData = {
                        name: null, // Will be auto-generated
                        inputs: [{ materialId: group.ore.id, quantity: 5 }],
                        outputs: [{ materialId: group.ingot.id, quantity: 1 }]
                    };

                    // Generate auto-name with ratio
                    var oreMat = materials.find(function (m) { return m.id == group.ore.id; });
                    var ingotMat = materials.find(function (m) { return m.id == group.ingot.id; });
                    if (oreMat && ingotMat) {
                        recipeData.name = 'TIER ' + group.tier + ': 5× ' + (oreMat.type || 'ore') + ' ' + oreMat.name + ' → ' + (ingotMat.type || 'ingot') + ' ' + ingotMat.name;
                    }

                    if (window.MiningAPI && window.MiningAPI.createRecipe) {
                        var res = await window.MiningAPI.createRecipe(recipeData);
                        if (res.ok && res.data) {
                            window.addRecipe({ ...recipeData, id: res.data.id });
                            created.push('Ore→Ingot: ' + group.name + ' (Tier ' + group.tier + ')');
                        } else {
                            window.addRecipe(recipeData);
                            created.push('Ore→Ingot: ' + group.name + ' (Tier ' + group.tier + ')');
                        }
                    } else {
                        window.addRecipe(recipeData);
                        created.push('Ore→Ingot: ' + group.name + ' (Tier ' + group.tier + ')');
                    }
                } else {
                    skipped.push('Ore→Ingot: ' + group.name + ' (Tier ' + group.tier + ')');
                }
            }
        }

        // Generate Ingot→Sheet recipes (3 Ingot → 1 Sheet)
        for (var key in byNameAndTier) {
            var group = byNameAndTier[key];
            if (group.ingot && group.sheet) {
                if (!recipeExists(group.ingot.id, group.sheet.id)) {
                    var recipeData = {
                        name: null, // Will be auto-generated
                        inputs: [{ materialId: group.ingot.id, quantity: 3 }],
                        outputs: [{ materialId: group.sheet.id, quantity: 1 }]
                    };

                    // Generate auto-name with ratio
                    var ingotMat = materials.find(function (m) { return m.id == group.ingot.id; });
                    var sheetMat = materials.find(function (m) { return m.id == group.sheet.id; });
                    if (ingotMat && sheetMat) {
                        recipeData.name = 'TIER ' + group.tier + ': 3× ' + (ingotMat.type || 'ingot') + ' ' + ingotMat.name + ' → ' + (sheetMat.type || 'sheet') + ' ' + sheetMat.name;
                    }

                    if (window.MiningAPI && window.MiningAPI.createRecipe) {
                        var res = await window.MiningAPI.createRecipe(recipeData);
                        if (res.ok && res.data) {
                            window.addRecipe({ ...recipeData, id: res.data.id });
                            created.push('Ingot→Sheet: ' + group.name + ' (Tier ' + group.tier + ')');
                        } else {
                            window.addRecipe(recipeData);
                            created.push('Ingot→Sheet: ' + group.name + ' (Tier ' + group.tier + ')');
                        }
                    } else {
                        window.addRecipe(recipeData);
                        created.push('Ingot→Sheet: ' + group.name + ' (Tier ' + group.tier + ')');
                    }
                } else {
                    skipped.push('Ingot→Sheet: ' + group.name + ' (Tier ' + group.tier + ')');
                }
            }
        }

        // Refresh data and UI
        await window.loadMiningData();
        window.renderRecipes();
        if (window.renderProfitAnalysis) window.renderProfitAnalysis();

        // Show feedback
        var message = '';
        if (created.length > 0) {
            message = 'Created ' + created.length + ' recipe(s):\n' + created.join('\n');
        }
        if (skipped.length > 0) {
            if (message) message += '\n\n';
            message += 'Skipped ' + skipped.length + ' (already exist):\n' + skipped.join('\n');
        }
        if (!message) {
            message = 'No missing recipes found. All Ore→Ingot and Ingot→Sheet recipes already exist.';
        }
        alert(message);
    };

    window.updateAllRecipeRatios = async function () {
        var materials = getMaterials();
        var recipes = window.getRecipes ? window.getRecipes() : [];

        if (recipes.length === 0) {
            alert('No recipes to update.');
            return;
        }

        if (!confirm('This will update all Ore→Ingot recipes to 5:1 ratio and all Ingot→Sheet recipes to 3:1 ratio. Continue?')) {
            return;
        }

        function getMaterialType(id) {
            var m = materials.find(function (mat) { return mat.id == id; });
            return m ? (m.type || 'ore').toLowerCase() : 'ore';
        }

        function isOreToIngotRecipe(recipe) {
            if (!recipe.inputs || !recipe.outputs || recipe.inputs.length === 0 || recipe.outputs.length === 0) return false;
            var hasOreInput = recipe.inputs.some(function (i) { return getMaterialType(i.materialId) === 'ore'; });
            var hasIngotOutput = recipe.outputs.some(function (o) { return getMaterialType(o.materialId) === 'ingot'; });
            return hasOreInput && hasIngotOutput;
        }

        function isIngotToSheetRecipe(recipe) {
            if (!recipe.inputs || !recipe.outputs || recipe.inputs.length === 0 || recipe.outputs.length === 0) return false;
            var hasIngotInput = recipe.inputs.some(function (i) { return getMaterialType(i.materialId) === 'ingot'; });
            var hasSheetOutput = recipe.outputs.some(function (o) { return getMaterialType(o.materialId) === 'sheet'; });
            return hasIngotInput && hasSheetOutput;
        }

        var updated = [];
        var skipped = [];

        for (var i = 0; i < recipes.length; i++) {
            var recipe = recipes[i];
            var needsUpdate = false;
            var updatedData = {
                name: recipe.name,
                inputs: JSON.parse(JSON.stringify(recipe.inputs || [])),
                outputs: JSON.parse(JSON.stringify(recipe.outputs || []))
            };

            if (isOreToIngotRecipe(recipe)) {
                // Update to 5 Ore → 1 Ingot
                // Find the ore input and ingot output, update their quantities
                var oreInputFound = false;
                var ingotOutputFound = false;

                updatedData.inputs.forEach(function (input) {
                    if (getMaterialType(input.materialId) === 'ore') {
                        input.quantity = 5;
                        oreInputFound = true;
                    }
                });

                updatedData.outputs.forEach(function (output) {
                    if (getMaterialType(output.materialId) === 'ingot') {
                        output.quantity = 1;
                        ingotOutputFound = true;
                    }
                });

                if (oreInputFound && ingotOutputFound) {
                    needsUpdate = true;
                }
            } else if (isIngotToSheetRecipe(recipe)) {
                // Update to 3 Ingot → 1 Sheet
                // Find the ingot input and sheet output, update their quantities
                var ingotInputFound = false;
                var sheetOutputFound = false;

                updatedData.inputs.forEach(function (input) {
                    if (getMaterialType(input.materialId) === 'ingot') {
                        input.quantity = 3;
                        ingotInputFound = true;
                    }
                });

                updatedData.outputs.forEach(function (output) {
                    if (getMaterialType(output.materialId) === 'sheet') {
                        output.quantity = 1;
                        sheetOutputFound = true;
                    }
                });

                if (ingotInputFound && sheetOutputFound) {
                    needsUpdate = true;
                }
            }

            if (needsUpdate) {
                // Regenerate name with new ratios
                var inputLabels = [];
                var outputLabels = [];

                updatedData.inputs.forEach(function (input) {
                    var mat = materials.find(function (m) { return m.id == input.materialId; });
                    if (mat) {
                        var label = (input.quantity !== 1 ? input.quantity + '× ' : '') + (mat.type || '') + ' ' + (mat.name || '');
                        inputLabels.push(label);
                    }
                });

                updatedData.outputs.forEach(function (output) {
                    var mat = materials.find(function (m) { return m.id == output.materialId; });
                    if (mat) {
                        var label = (output.quantity !== 1 ? output.quantity + '× ' : '') + (mat.type || '') + ' ' + (mat.name || '');
                        outputLabels.push(label);
                    }
                });

                if (inputLabels.length > 0 && outputLabels.length > 0) {
                    var tier = null;
                    if (updatedData.inputs.length > 0) {
                        var inputMat = materials.find(function (m) { return m.id == updatedData.inputs[0].materialId; });
                        if (inputMat) tier = inputMat.tier || 1;
                    }
                    if (tier) {
                        updatedData.name = 'TIER ' + tier + ': ' + inputLabels.join(' + ') + ' → ' + outputLabels.join(' + ');
                    } else {
                        updatedData.name = inputLabels.join(' + ') + ' → ' + outputLabels.join(' + ');
                    }
                }

                if (window.MiningAPI && window.MiningAPI.updateRecipe) {
                    var res = await window.MiningAPI.updateRecipe(recipe.id, updatedData);
                    if (res.ok && res.data) {
                        window.updateRecipe(recipe.id, updatedData);
                        updated.push(updatedData.name || 'Recipe #' + recipe.id);
                    } else {
                        window.updateRecipe(recipe.id, updatedData);
                        updated.push(updatedData.name || 'Recipe #' + recipe.id);
                    }
                } else {
                    window.updateRecipe(recipe.id, updatedData);
                    updated.push(updatedData.name || 'Recipe #' + recipe.id);
                }
            } else {
                skipped.push((recipe.name || 'Recipe #' + recipe.id));
            }
        }

        // Refresh data and UI
        await window.loadMiningData();
        window.renderRecipes();
        if (window.renderProfitAnalysis) window.renderProfitAnalysis();

        // Show feedback
        var message = '';
        if (updated.length > 0) {
            message = 'Updated ' + updated.length + ' recipe(s):\n' + updated.join('\n');
        }
        if (skipped.length > 0) {
            if (message) message += '\n\n';
            message += 'Skipped ' + skipped.length + ' (not Ore→Ingot or Ingot→Sheet):\n' + skipped.join('\n');
        }
        if (message) {
            alert(message);
        }
    };

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', wireAddRecipeModal);
    } else {
        setTimeout(wireAddRecipeModal, 0);
    }
})();
