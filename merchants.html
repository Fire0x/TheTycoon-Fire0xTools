<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traveling Merchants - Fire0x Incorporated</title>
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="images/SiteLogo.png">
    <!-- Bootstrap CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom CSS -->
    <link href="css/styles.css" rel="stylesheet">
    <style>
        .merchant-card {
            margin-bottom: 1rem;
            border: 1px solid var(--card-border);
            background-color: var(--card-bg);
            color: var(--text-color);
        }
        .timer-display {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--link-color);
        }
        .timer-complete {
            color: #28a745 !important;
        }
        .merchant-icon {
            font-size: 2rem;
            margin-right: 0.5rem;
        }
        .paste-area {
            background-color: var(--card-bg);
            border: 2px dashed var(--card-border);
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-bottom: 2rem;
            color: var(--text-color);
        }
        .paste-area textarea {
            background-color: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--card-border);
        }
        .paste-area textarea:focus {
            background-color: var(--bg-color);
            color: var(--text-color);
            border-color: var(--link-color);
        }
        .paste-area pre {
            background-color: var(--bg-color) !important;
            color: var(--text-color) !important;
            border: 1px solid var(--card-border);
        }
        .aest-time {
            font-size: 1.1rem;
            padding: 0.5rem;
            background-color: var(--card-bg);
            border-radius: 0.25rem;
            color: var(--text-color);
        }
        .card-title {
            color: var(--text-color);
        }
        .text-muted {
            color: var(--text-color) !important;
            opacity: 0.7;
        }
        .text-info {
            color: var(--link-color) !important;
        }
        .merchant-info {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .merchant-info strong {
            min-width: 120px;
        }
        kbd {
            display: inline-block;
            padding: 0.2rem 0.4rem;
            font-size: 0.875rem;
            font-weight: 700;
            line-height: 1;
            color: var(--text-color);
            text-align: center;
            background-color: var(--bg-color);
            border: 1px solid var(--card-border);
            border-radius: 0.25rem;
            box-shadow: inset 0 -1px 0 var(--card-border);
        }
    </style>
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <div class="container">
            <a class="navbar-brand" href="#"><img src="images/SiteLogo.png" alt="Site Logo" style="height: 40px; margin-right: 10px;">Fire0x Incorporated</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="merchants.html">Traveling Merchants</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="checklist.html">Checklist</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="VehicleDeliveries.html">Vehicle Deliveries</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="education_timer.html">Education Timer</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="container py-5">
        <h1 class="glow-text">üìã Traveling Merchants</h1>
        <p class="aest-time mb-4">
            <strong>Current Time (Local):</strong> 
            <span id="aestTime"></span>
        </p>

        <!-- How to Use Section -->
        <div class="row">
            <div class="col-md-10 mx-auto">
                <div class="card merchant-card mb-4">
                    <div class="card-body">
                        <h5 class="card-title mb-3">üìñ How to Use This Page</h5>
                        <div class="mb-3">
                            <h6 class="mb-2"><strong>Step 1: In-Game</strong></h6>
                            <p class="mb-2">Open your chat and type the command:</p>
                            <code class="d-block p-2 mb-3" style="background-color: var(--bg-color); border: 1px solid var(--card-border); border-radius: 0.25rem; color: var(--link-color);">/merchants</code>
                            
                            <h6 class="mb-2"><strong>Step 2: Copy the Data</strong></h6>
                            <p class="mb-2">Select all the merchant data that appears:</p>
                            <ul class="mb-3">
                                <li><strong>Windows/Linux:</strong> Press <kbd>Ctrl</kbd> + <kbd>A</kbd> then <kbd>Ctrl</kbd> + <kbd>C</kbd></li>
                                <li><strong>Mac:</strong> Press <kbd>Cmd</kbd> + <kbd>A</kbd> then <kbd>Cmd</kbd> + <kbd>C</kbd></li>
                            </ul>
                            
                            <h6 class="mb-2"><strong>Step 3: Paste on This Page</strong></h6>
                            <p class="mb-2">Click in the text area below and paste your data:</p>
                            <ul class="mb-3">
                                <li><strong>Windows/Linux:</strong> Press <kbd>Ctrl</kbd> + <kbd>V</kbd></li>
                                <li><strong>Mac:</strong> Press <kbd>Cmd</kbd> + <kbd>V</kbd></li>
                            </ul>
                            
                            <h6 class="mb-2"><strong>Step 4: Save</strong></h6>
                            <p class="mb-0">Click the <span class="badge bg-primary">Parse & Save Merchants</span> button to add them to your tracker!</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-10 mx-auto">
                <!-- Paste Area -->
                <div class="paste-area">
                    <h5 class="mb-3">üìã Paste Merchant Data</h5>
                    <p class="text-muted small mb-3">Paste your merchant data here. Example format:</p>
                    <pre class="bg-light p-2 mb-3 small" style="border-radius: 0.25rem;">‚òï Coffee
Merchant #1
üìç Location: Morningwood South - Los Santos
üìè Distance: 641m away
üí∞ Price: $74.62 per unit
üõí Buying: ‚òï Coffee
‚è∞ Next Rotation: 4h 53m
üìç Set Waypoint

üçä Oranges
Merchant #2
üìç Location: Terminal - Los Santos
üìè Distance: 1402m away
üí∞ Price: $12.14 per unit
üõí Buying: üçä Oranges
‚è∞ Next Rotation: 4h 53m
üìç Set Waypoint</pre>
                    <textarea id="pasteInput" class="form-control" rows="6" placeholder="Paste merchant data here..."></textarea>
                    <div class="mt-3">
                        <button class="btn btn-primary" onclick="parseAndSave()">Parse & Save Merchants</button>
                        <button class="btn btn-danger" onclick="clearAllMerchants()">Clear All Merchants</button>
                        <button class="btn btn-outline-secondary btn-sm ms-2" id="debugToggleBtn" onclick="toggleDebug()">
                            <span id="debugToggleText">üîç Debug: OFF</span>
                        </button>
                    </div>
                </div>

                <!-- Merchants Rotation Section -->
                <div id="merchantsRotationSection" class="mb-4" style="display: none;">
                    <div class="card merchant-card">
                        <div class="card-body">
                            <h5 class="card-title mb-3">üîÑ Merchant Rotation</h5>
                            <div id="merchantsRotationContainer">
                                <!-- Merchant rotations will be displayed here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Best Prices Section -->
                <div id="bestPricesSection" class="mb-4" style="display: none;">
                    <div class="card merchant-card">
                        <div class="card-body">
                            <h5 class="card-title mb-3">üí∞ Best Price to Sell</h5>
                            <div id="bestPricesContainer">
                                <!-- Best prices will be displayed here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Merchants Container -->
                <div id="merchantsContainer">
                    <!-- Merchant cards will be dynamically generated here -->
                </div>

                <!-- Empty State -->
                <div id="emptyState" class="text-center py-5" style="display: none;">
                    <p class="text-muted">No active merchants. Paste merchant data above to get started.</p>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="bg-light py-3">
        <div class="container text-center">
            <p>&copy; 2025-2026 Fire0x Incorporated. The Tycoon is owned and created by OneLonelyDad (Troublesum). All rights reserved.</p>
            <div id="version-display" class="mt-2" style="font-size: 0.875rem; color: #6c757d;">
                <!-- Version will be inserted here by version.js -->
            </div>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="js/bootstrap.bundle.min.js"></script>
    <!-- Version Manager -->
    <script src="js/version.js"></script>
    <!-- Theme JS -->
    <script src="js/theme.js"></script>
    <script>
        // Storage keys
        const STORAGE_KEY = 'traveling_merchants';
        const DEBUG_STORAGE_KEY = 'merchants_debug_enabled';
        
        // Store merchants data
        let merchants = {};
        
        // Debug mode flag
        let debugEnabled = false;
        
        // Initialize debug mode from storage
        function initDebugMode() {
            const stored = localStorage.getItem(DEBUG_STORAGE_KEY);
            debugEnabled = stored === 'true';
            updateDebugToggleUI();
        }
        
        // Toggle debug mode
        function toggleDebug() {
            debugEnabled = !debugEnabled;
            localStorage.setItem(DEBUG_STORAGE_KEY, debugEnabled.toString());
            updateDebugToggleUI();
            debugLog('Debug mode ' + (debugEnabled ? 'ENABLED' : 'DISABLED'));
        }
        
        // Update debug toggle button UI
        function updateDebugToggleUI() {
            const btn = document.getElementById('debugToggleBtn');
            const text = document.getElementById('debugToggleText');
            if (btn && text) {
                if (debugEnabled) {
                    btn.classList.remove('btn-outline-secondary');
                    btn.classList.add('btn-warning');
                    text.textContent = 'üîç Debug: ON';
                } else {
                    btn.classList.remove('btn-warning');
                    btn.classList.add('btn-outline-secondary');
                    text.textContent = 'üîç Debug: OFF';
                }
            }
        }
        
        // Debug logging function
        function debugLog(...args) {
            if (debugEnabled) {
                console.log('[Merchants Debug]', ...args);
            }
        }
        
        // Debug error logging function
        function debugError(...args) {
            if (debugEnabled) {
                console.error('[Merchants Debug]', ...args);
            } else {
                console.error(...args);
            }
        }

        // Format local date/time
        function formatAESTDateTime(date) {
            const dateOptions = {
                day: '2-digit',
                month: 'short',
                year: 'numeric'
            };
            const timeOptions = {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            };
            const dateStr = date.toLocaleDateString('en-US', dateOptions);
            const timeStr = date.toLocaleTimeString('en-US', timeOptions);
            return `${dateStr} ${timeStr}`;
        }

        // Update local time
        function updateAESTTime() {
            const now = new Date();
            const aestTime = formatAESTDateTime(now);
            document.getElementById('aestTime').textContent = aestTime;
        }

        // Parse time string to seconds
        function parseTimeToSeconds(timeStr) {
            let totalSeconds = 0;
            
            // Match days
            const daysMatch = timeStr.match(/(\d+)d/);
            if (daysMatch) {
                totalSeconds += parseInt(daysMatch[1]) * 86400;
            }
            
            // Match hours
            const hoursMatch = timeStr.match(/(\d+)h/);
            if (hoursMatch) {
                totalSeconds += parseInt(hoursMatch[1]) * 3600;
            }
            
            // Match minutes
            const minutesMatch = timeStr.match(/(\d+)m/);
            if (minutesMatch) {
                totalSeconds += parseInt(minutesMatch[1]) * 60;
            }
            
            // Match seconds
            const secondsMatch = timeStr.match(/(\d+)s/);
            if (secondsMatch) {
                totalSeconds += parseInt(secondsMatch[1]);
            }
            
            return totalSeconds;
        }

        // Parse pasted text
        function parseMerchantData(text) {
            debugLog('Parsing merchant data, input length:', text.length);
            const merchants = [];
            
            // Normalize the text: remove "√ó" separators, "Set Waypoint" buttons
            let normalizedText = text
                .replace(/√ó/g, '\n')
                .replace(/üìç Set Waypoint/gi, '\n---SEPARATOR---\n')
                .replace(/Set Waypoint/gi, '') // Remove any remaining "Set Waypoint" text
                .replace(/üìç\s*$/gm, ''); // Remove standalone waypoint emoji at end of lines
            
            // Split by separators first (Set Waypoint markers)
            let blocks = normalizedText.split(/\n\s*---SEPARATOR---\s*\n/).filter(block => block.trim());
            debugLog('Initial blocks found:', blocks.length);
            
            // If no separators found or only one block, try alternative splitting methods
            if (blocks.length <= 1) {
                // Try splitting by "Merchant #" pattern - each new merchant number starts a new block
                const lines = normalizedText.split('\n');
                const newBlocks = [];
                let currentBlock = [];
                let lastMerchantNum = null;
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    const merchantMatch = line.match(/Merchant #(\d+)/);
                    
                    if (merchantMatch) {
                        const merchantNum = parseInt(merchantMatch[1]);
                        // If we find a merchant number and we already have content, start a new block
                        if (currentBlock.length > 0 && lastMerchantNum !== null && merchantNum !== lastMerchantNum) {
                            newBlocks.push(currentBlock.join('\n'));
                            currentBlock = [];
                        }
                        lastMerchantNum = merchantNum;
                    }
                    
                    // Skip empty lines at the start of a block
                    if (line || currentBlock.length > 0) {
                        currentBlock.push(line);
                    }
                }
                
                if (currentBlock.length > 0) {
                    newBlocks.push(currentBlock.join('\n'));
                }
                
                if (newBlocks.length > 1) {
                    blocks = newBlocks;
                    debugLog('Split by merchant numbers, found:', blocks.length, 'blocks');
                } else if (blocks.length === 1) {
                    // Last resort: split by triple newlines
                    blocks = normalizedText.split(/\n\s*\n\s*\n/).filter(block => block.trim());
                    debugLog('Split by triple newlines, found:', blocks.length, 'blocks');
                }
            }
            
            debugLog('Processing', blocks.length, 'merchant blocks');
            blocks.forEach((block, index) => {
                debugLog(`Processing block ${index + 1}/${blocks.length}`);
                const lines = block.split('\n')
                    .map(l => l.trim())
                    .filter(l => l && !l.match(/^üìç Set Waypoint$/i) && !l.match(/Set Waypoint/i) && l !== '√ó' && l !== 'üìç');
                
                if (lines.length < 2) return;
                
                // Find first line with emoji and item name (could be first line or after empty lines)
                let emoji = '';
                let itemName = '';
                let firstLineIndex = -1;
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    // Match emoji followed by item name (e.g., "‚òï Coffee" or "‚òï\nCoffee")
                    const emojiMatch = line.match(/^([^\s]+)\s+(.+)$/);
                    if (emojiMatch) {
                        emoji = emojiMatch[1];
                        itemName = emojiMatch[2].trim();
                        firstLineIndex = i;
                        break;
                    }
                    // Also check if emoji is on one line and name on next
                    if (i < lines.length - 1) {
                        const emojiOnly = line.match(/^([^\s]+)$/);
                        const nextLine = lines[i + 1];
                        if (emojiOnly && nextLine && !nextLine.match(/^(Merchant|üìç|üìè|üí∞|üõí|‚è∞)/)) {
                            emoji = emojiOnly[1];
                            itemName = nextLine.trim();
                            firstLineIndex = i;
                            break;
                        }
                    }
                }
                
                if (!emoji || !itemName) return;
                
                // Find merchant number
                const merchantMatch = lines.find(line => line.includes('Merchant #'));
                if (!merchantMatch) return;
                const merchantNum = merchantMatch.match(/Merchant #(\d+)/)?.[1];
                if (!merchantNum) return;
                
                // Find location - handle both "üìç Location: value" and "üìç Location\nvalue" formats
                let location = '';
                const locationIndex = lines.findIndex(line => line.includes('üìç Location'));
                if (locationIndex !== -1) {
                    const locationLine = lines[locationIndex];
                    // Check if value is on same line
                    if (locationLine.includes(':')) {
                        location = locationLine.replace(/üìç Location:?\s*/, '').trim();
                    } else {
                        // Value is on next line
                        if (locationIndex + 1 < lines.length) {
                            location = lines[locationIndex + 1].trim();
                        }
                    }
                }
                
                // Find distance
                let distance = '';
                const distanceIndex = lines.findIndex(line => line.includes('üìè Distance'));
                if (distanceIndex !== -1) {
                    const distanceLine = lines[distanceIndex];
                    if (distanceLine.includes(':')) {
                        distance = distanceLine.replace(/üìè Distance:?\s*/, '').trim();
                    } else {
                        if (distanceIndex + 1 < lines.length) {
                            distance = lines[distanceIndex + 1].trim();
                        }
                    }
                }
                
                // Find price
                let price = '';
                const priceIndex = lines.findIndex(line => line.includes('üí∞ Price'));
                if (priceIndex !== -1) {
                    const priceLine = lines[priceIndex];
                    if (priceLine.includes(':')) {
                        price = priceLine.replace(/üí∞ Price:?\s*/, '').trim();
                    } else {
                        if (priceIndex + 1 < lines.length) {
                            price = lines[priceIndex + 1].trim();
                        }
                    }
                }
                
                // Find buying
                let buying = itemName; // Default to item name
                const buyingIndex = lines.findIndex(line => line.includes('üõí Buying'));
                if (buyingIndex !== -1) {
                    const buyingLine = lines[buyingIndex];
                    if (buyingLine.includes(':')) {
                        buying = buyingLine.replace(/üõí Buying:?\s*/, '').trim();
                    } else {
                        if (buyingIndex + 1 < lines.length) {
                            buying = lines[buyingIndex + 1].trim();
                        }
                    }
                }
                
                // Find next rotation time
                let rotationTimeStr = '';
                const rotationIndex = lines.findIndex(line => line.includes('‚è∞ Next Rotation'));
                if (rotationIndex !== -1) {
                    const rotationLine = lines[rotationIndex];
                    if (rotationLine.includes(':')) {
                        rotationTimeStr = rotationLine.replace(/‚è∞ Next Rotation:?\s*/, '').trim();
                    } else {
                        if (rotationIndex + 1 < lines.length) {
                            rotationTimeStr = lines[rotationIndex + 1].trim();
                        }
                    }
                }
                
                const rotationSeconds = rotationTimeStr ? parseTimeToSeconds(rotationTimeStr) : 0;
                
                if (itemName && merchantNum && rotationSeconds > 0) {
                    const merchant = {
                        emoji: emoji,
                        itemName: itemName,
                        merchantNumber: parseInt(merchantNum),
                        location: location,
                        distance: distance,
                        price: price,
                        buying: buying || itemName,
                        secondsRemaining: rotationSeconds,
                        originalRemaining: rotationSeconds,
                        startTime: new Date().toISOString()
                    };
                    merchants.push(merchant);
                    debugLog('Parsed merchant:', merchant.merchantNumber, '-', merchant.itemName, '- Rotation:', rotationTimeStr);
                } else {
                    debugLog('Skipped invalid merchant block - itemName:', itemName, 'merchantNum:', merchantNum, 'rotationSeconds:', rotationSeconds);
                }
            });
            
            debugLog('Total merchants parsed:', merchants.length);
            return merchants;
        }

        // Save to localStorage
        function saveToStorage() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(merchants));
            debugLog('Saved merchants to localStorage');
        }

        // Load from localStorage
        function loadFromStorage() {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (stored) {
                try {
                    merchants = JSON.parse(stored);
                    // Convert startTime strings back to dates and recalculate remaining time
                    const now = new Date();
                    Object.keys(merchants).forEach(key => {
                        const merchant = merchants[key];
                        // Preserve original remaining time if it exists
                        if (!merchant.originalRemaining) {
                            merchant.originalRemaining = merchant.secondsRemaining;
                        }
                        const startTime = new Date(merchant.startTime);
                        const elapsed = Math.floor((now - startTime) / 1000);
                        const originalRemaining = merchant.originalRemaining || merchant.secondsRemaining;
                        merchant.secondsRemaining = Math.max(0, originalRemaining - elapsed);
                        merchant.originalRemaining = originalRemaining;
                        merchant.startTime = startTime.toISOString();
                    });
                    saveToStorage();
                    debugLog('Loaded merchants from storage:', Object.keys(merchants).length, 'merchants');
                } catch (e) {
                    debugError('Error loading from storage:', e);
                    merchants = {};
                }
            }
        }

        // Parse and save
        function parseAndSave() {
            const input = document.getElementById('pasteInput').value;
            debugLog('parseAndSave called, input length:', input.length);
            if (!input.trim()) {
                alert('Please paste merchant data first!');
                return;
            }
            
            const parsed = parseMerchantData(input);
            debugLog('Parsed merchants:', parsed.length);
            if (parsed.length === 0) {
                alert('No valid merchant data found. Please check the format.');
                return;
            }
            
            // Add or update merchants
            parsed.forEach(merchant => {
                const key = `merchant-${merchant.merchantNumber}`;
                const isUpdate = merchants[key] !== undefined;
                // Ensure originalRemaining is set
                if (!merchant.originalRemaining) {
                    merchant.originalRemaining = merchant.secondsRemaining;
                }
                // Reset startTime to now when updating
                merchant.startTime = new Date().toISOString();
                merchants[key] = merchant;
                debugLog(isUpdate ? 'Updated' : 'Added', 'merchant:', key);
            });
            
            saveToStorage();
            debugLog('Saved to storage, total merchants:', Object.keys(merchants).length);
            document.getElementById('pasteInput').value = '';
            renderMerchants();
            renderMerchantsRotation(); // Update rotation section
            
            alert(`Successfully added ${parsed.length} merchant(s)!`);
        }

        // Format time remaining
        function formatTime(seconds) {
            if (seconds <= 0) {
                return 'Rotated';
            }
            
            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;

            let result = '';
            if (days > 0) {
                result += days + 'd ';
            }
            if (hours > 0 || days > 0) {
                result += hours + 'h ';
            }
            if (minutes > 0 || hours > 0 || days > 0) {
                result += minutes + 'm';
            }
            if (days === 0 && hours === 0 && minutes === 0) {
                result = secs + 's';
            }

            return result.trim();
        }

        // Get expiration time
        function getExpirationTime(secondsRemaining) {
            const now = new Date();
            const expiration = new Date(now.getTime() + secondsRemaining * 1000);
            return formatAESTDateTime(expiration);
        }

        // Extract numeric price from price string (e.g., "$74.62 per unit" -> 74.62)
        function extractPrice(priceStr) {
            if (!priceStr) return 0;
            // Match number with optional decimal (e.g., "$74.62", "74.62", "$74")
            const match = priceStr.match(/(\d+\.?\d*)/);
            return match ? parseFloat(match[1]) : 0;
        }

        // Calculate best prices grouped by item
        function calculateBestPrices() {
            const bestPrices = {};
            
            Object.keys(merchants).forEach(key => {
                const merchant = merchants[key];
                // Skip if merchant has rotated
                if (merchant.secondsRemaining <= 0) return;
                
                const buyingItem = merchant.buying || merchant.itemName;
                const price = extractPrice(merchant.price);
                
                if (!bestPrices[buyingItem]) {
                    bestPrices[buyingItem] = {
                        item: buyingItem,
                        emoji: merchant.emoji,
                        price: price,
                        priceStr: merchant.price,
                        merchantNumber: merchant.merchantNumber,
                        location: merchant.location,
                        distance: merchant.distance
                    };
                } else {
                    // Update if this merchant has a higher price
                    if (price > bestPrices[buyingItem].price) {
                        bestPrices[buyingItem] = {
                            item: buyingItem,
                            emoji: merchant.emoji,
                            price: price,
                            priceStr: merchant.price,
                            merchantNumber: merchant.merchantNumber,
                            location: merchant.location,
                            distance: merchant.distance
                        };
                    }
                }
            });
            
            return bestPrices;
        }

        // Render merchants rotation section
        function renderMerchantsRotation() {
            const section = document.getElementById('merchantsRotationSection');
            const container = document.getElementById('merchantsRotationContainer');
            
            const activeKeys = Object.keys(merchants).filter(key => {
                return merchants[key].secondsRemaining > 0;
            });
            
            if (activeKeys.length === 0) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            
            // Group merchants by their next rotation time (rounded to nearest 10 seconds for grouping)
            const groupedByRotation = {};
            
            activeKeys.forEach(key => {
                const merchant = merchants[key];
                // Round to nearest 10 seconds for grouping
                const roundedTime = Math.round(merchant.secondsRemaining / 10) * 10;
                
                if (!groupedByRotation[roundedTime]) {
                    groupedByRotation[roundedTime] = [];
                }
                groupedByRotation[roundedTime].push(merchant);
            });
            
            // Sort groups by rotation time (soonest first)
            const sortedGroups = Object.keys(groupedByRotation)
                .map(time => parseInt(time))
                .sort((a, b) => a - b);
            
            container.innerHTML = sortedGroups.map(roundedTime => {
                const merchantsInGroup = groupedByRotation[roundedTime];
                const merchantNumbers = merchantsInGroup
                    .map(m => m.merchantNumber)
                    .sort((a, b) => a - b);
                
                // Use the first merchant's actual remaining time for display
                const actualTime = merchantsInGroup[0].secondsRemaining;
                const timeDisplay = formatTime(actualTime);
                const statusClass = actualTime <= 0 ? 'timer-complete' : '';
                
                // Create a unique key for this group based on rounded rotation time
                const groupKey = `rotation-${roundedTime}`;
                
                return `
                    <div class="d-flex justify-content-between align-items-center mb-2 p-2" style="background-color: var(--card-bg); border-radius: 0.25rem; border: 1px solid var(--card-border);">
                        <div class="d-flex align-items-center">
                            <div>
                                <strong>Merchant Rotation:</strong> ${merchantNumbers.map(n => `<span style="color: var(--link-color); font-weight: bold;">#${n}</span>`).join(' ')}
                            </div>
                        </div>
                        <div class="text-end">
                            <div class="timer-display ${statusClass}" id="rotation-timer-${groupKey}" style="font-size: 1.2rem;">
                                ${timeDisplay}
                            </div>
                            <div class="small text-muted">Next Rotation</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Render best prices section
        function renderBestPrices() {
            const section = document.getElementById('bestPricesSection');
            const container = document.getElementById('bestPricesContainer');
            
            const bestPrices = calculateBestPrices();
            const items = Object.keys(bestPrices);
            
            if (items.length === 0) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            
            // Sort by price (highest first)
            items.sort((a, b) => bestPrices[b].price - bestPrices[a].price);
            
            container.innerHTML = items.map(item => {
                const best = bestPrices[item];
                return `
                    <div class="d-flex justify-content-between align-items-center mb-2 p-2" style="background-color: var(--card-bg); border-radius: 0.25rem; border: 1px solid var(--card-border);">
                        <div class="d-flex align-items-center">
                            <span class="merchant-icon">${best.emoji}</span>
                            <div>
                                <strong>${escapeHtml(best.item)}</strong>
                                <div class="small text-muted">
                                    Merchant #${best.merchantNumber} ‚Ä¢ ${escapeHtml(best.location || 'N/A')}
                                    ${best.distance ? ` ‚Ä¢ ${escapeHtml(best.distance)}` : ''}
                                </div>
                            </div>
                        </div>
                        <div class="text-end">
                            <div class="text-success" style="font-size: 1.2rem; font-weight: bold;">
                                ${escapeHtml(best.priceStr || `$${best.price.toFixed(2)}`)}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Render merchant cards
        function renderMerchants() {
            const container = document.getElementById('merchantsContainer');
            const emptyState = document.getElementById('emptyState');
            
            const keys = Object.keys(merchants).sort((a, b) => {
                return merchants[a].merchantNumber - merchants[b].merchantNumber;
            });
            
            if (keys.length === 0) {
                container.innerHTML = '';
                emptyState.style.display = 'block';
                return;
            }
            
            emptyState.style.display = 'none';
            
            container.innerHTML = keys.map(key => {
                const merchant = merchants[key];
                const timeDisplay = formatTime(merchant.secondsRemaining);
                const expiration = merchant.secondsRemaining > 0 ? getExpirationTime(merchant.secondsRemaining) : 'Rotated';
                
                const statusClass = merchant.secondsRemaining <= 0 ? 'timer-complete' : '';
                
                return `
                    <div class="card merchant-card" id="merchant-${key}">
                        <div class="card-body">
                            <div class="d-flex justify-content-between align-items-start mb-3">
                                <div class="d-flex align-items-center">
                                    <span class="merchant-icon">${merchant.emoji}</span>
                                    <div>
                                        <h4 class="card-title mb-1">${escapeHtml(merchant.itemName)}</h4>
                                        <p class="text-muted mb-0">Merchant #${merchant.merchantNumber}</p>
                                    </div>
                                </div>
                                <div class="text-end">
                                    <div class="timer-display ${statusClass}" id="timer-display-${key}">${timeDisplay}</div>
                                    <small class="text-muted">Next Rotation</small>
                                    <div class="mt-2">
                                        <small class="text-muted">Rotates: <span id="expires-${key}" class="text-info">${expiration}</span></small>
                                    </div>
                                </div>
                            </div>
                            <hr>
                            <div class="merchant-info">
                                <strong>üìç Location:</strong>
                                <span>${escapeHtml(merchant.location || 'N/A')}</span>
                            </div>
                            <div class="merchant-info">
                                <strong>üìè Distance:</strong>
                                <span>${escapeHtml(merchant.distance || 'N/A')}</span>
                            </div>
                            <div class="merchant-info">
                                <strong>üí∞ Price:</strong>
                                <span>${escapeHtml(merchant.price || 'N/A')}</span>
                            </div>
                            <div class="merchant-info">
                                <strong>üõí Buying:</strong>
                                <span>${escapeHtml(merchant.buying || merchant.itemName)}</span>
                            </div>
                            <hr>
                            <button class="btn btn-danger ms-2" onclick="removeMerchant('${key}')">üóëÔ∏è Remove Merchant</button>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Render merchants rotation and best prices after rendering merchants
            renderMerchantsRotation();
            renderBestPrices();
        }

        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Store original remaining time when merchant starts
        function getOriginalRemainingTime(merchant) {
            if (!merchant.originalRemaining) {
                merchant.originalRemaining = merchant.secondsRemaining;
            }
            return merchant.originalRemaining;
        }

        // Update timers
        function updateTimers() {
            const now = new Date();
            let hasChanges = false;
            
            Object.keys(merchants).forEach(key => {
                const merchant = merchants[key];
                const originalRemaining = getOriginalRemainingTime(merchant);
                
                if (originalRemaining > 0) {
                    const startTime = new Date(merchant.startTime);
                    const elapsed = Math.floor((now - startTime) / 1000);
                    const newRemaining = Math.max(0, originalRemaining - elapsed);
                    
                    // Only update if changed
                    if (newRemaining !== merchant.secondsRemaining) {
                        merchant.secondsRemaining = newRemaining;
                        hasChanges = true;
                    }
                    
                    const timerElement = document.getElementById(`timer-display-${key}`);
                    const expiresElement = document.getElementById(`expires-${key}`);
                    
                    if (timerElement) {
                        const timeDisplay = formatTime(merchant.secondsRemaining);
                        timerElement.textContent = timeDisplay;
                        
                        if (merchant.secondsRemaining <= 0) {
                            timerElement.classList.add('timer-complete');
                        } else {
                            timerElement.classList.remove('timer-complete');
                        }
                    }
                    
                    if (expiresElement && merchant.secondsRemaining > 0) {
                        expiresElement.textContent = getExpirationTime(merchant.secondsRemaining);
                    } else if (expiresElement) {
                        expiresElement.textContent = 'Rotated';
                    }
                }
            });
            
            if (hasChanges) {
                saveToStorage();
                renderMerchantsRotation(); // Update rotation section when timers change
                renderBestPrices(); // Update best prices when merchants rotate
            }
            
            // Update rotation timers
            const activeKeys = Object.keys(merchants).filter(key => {
                return merchants[key].secondsRemaining > 0;
            });
            
            // Group by rotation time and update timers
            const groupedByRotation = {};
            activeKeys.forEach(key => {
                const merchant = merchants[key];
                const roundedTime = Math.round(merchant.secondsRemaining / 10) * 10;
                if (!groupedByRotation[roundedTime]) {
                    groupedByRotation[roundedTime] = [];
                }
                groupedByRotation[roundedTime].push({ key, merchant });
            });
            
            Object.keys(groupedByRotation).forEach(roundedTime => {
                const group = groupedByRotation[roundedTime];
                const actualTime = group[0].merchant.secondsRemaining;
                const groupKey = `rotation-${roundedTime}`;
                const timerElement = document.getElementById(`rotation-timer-${groupKey}`);
                
                if (timerElement) {
                    const timeDisplay = formatTime(actualTime);
                    timerElement.textContent = timeDisplay;
                    
                    if (actualTime <= 0) {
                        timerElement.classList.add('timer-complete');
                    } else {
                        timerElement.classList.remove('timer-complete');
                    }
                }
            });
        }

        // Set waypoint (placeholder function)
        function setWaypoint(key) {
            const merchant = merchants[key];
            if (!merchant) return;
            
            // This would integrate with the game's waypoint system
            alert(`Waypoint set for ${merchant.itemName} at ${merchant.location}`);
        }

        // Remove merchant
        function removeMerchant(key) {
            const merchant = merchants[key];
            if (!merchant) {
                debugLog('Attempted to remove non-existent merchant:', key);
                return;
            }
            
            if (confirm(`Are you sure you want to remove Merchant #${merchant.merchantNumber} (${merchant.itemName})?`)) {
                debugLog('Removing merchant:', key, merchant.itemName);
                delete merchants[key];
                saveToStorage();
                renderMerchants();
                renderMerchantsRotation(); // Update rotation section
                renderBestPrices(); // Update best prices
            }
        }

        // Clear all merchants
        function clearAllMerchants() {
            const count = Object.keys(merchants).length;
            debugLog('clearAllMerchants called, current count:', count);
            if (count === 0) {
                alert('No merchants to clear.');
                return;
            }
            
            if (confirm('Are you sure you want to clear ALL merchants?')) {
                debugLog('Clearing all merchants');
                merchants = {};
                saveToStorage();
                renderMerchants();
                renderMerchantsRotation(); // Update rotation section
                renderBestPrices(); // Update best prices
                alert('All merchants cleared!');
            }
        }

        // Initialize
        initDebugMode();
        loadFromStorage();
        renderMerchants();
        updateAESTTime();
        setInterval(updateAESTTime, 1000);
        updateTimers();
        setInterval(updateTimers, 1000);
        debugLog('Page initialized');
    </script>
</body>
</html>
